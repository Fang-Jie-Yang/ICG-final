<html>

<head>
<title>ICG WebGL &mdash; HW1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="./js/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./js/webgl-utils.js"></script>

<script id="ToonFragmentShader" type="fragment">
    precision mediump float;

    varying vec4 fragColor;
    varying vec3 fragNormal;
    varying vec3 fragPosition;

    void main(void) {

        float sunIntensity = 0.9;
        vec3 sunPositions[3];
        sunPositions[0] = vec3(40.0, 0.0, -80.0);
        sunPositions[1] = vec3(-40.0, .0, -80.0);
        sunPositions[2] = vec3(0.0, -50.0, -80.0);

        vec3 eyeDirection = normalize(-fragPosition);

        float ka = 0.2;
        float kd = 0.6;
        float ks = 0.2;

        float lightIntensity = ka;
        float diffuse;
        float specular;
        
        vec3 sunDirection;

        for(int i = 0; i < 3; i++) {
            sunDirection = normalize(fragPosition - sunPositions[i]);
            diffuse = max(dot(fragNormal, sunDirection), 0.0);
            vec3 reflectDirection = 2.0 * dot(sunDirection, fragNormal) * fragNormal - sunDirection;
            specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), 0.0);

            if(diffuse >= 0.66)
                diffuse = 0.66;
            else if(diffuse >= 0.33)
                diffuse = 0.33;
            else
                diffuse = 0.0;

            if(specular >= 0.5)
                specular = 0.5;
            else
                specular = 0.0;

            lightIntensity += specular * ks * sunIntensity + diffuse * kd * sunIntensity;
        }
        gl_FragColor = vec4(fragColor.xyz * lightIntensity, 1.0);

    }
</script>

<script id="ToonVertexShader" type="vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aFrontColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	varying vec4 fragColor;
    varying vec3 fragNormal;
    varying vec3 fragPosition;

    void main(void) {

        fragColor = vec4(aFrontColor.rgb, 1.0);
        fragNormal = normalize((uMVMatrix * vec4(aVertexNormal, 0.0)).xyz);
        fragPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;

        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>


<script id="PhongFragmentShader" type="fragment">
    precision mediump float;

    varying vec4 fragColor;
    varying vec3 fragNormal;
    varying vec3 fragPosition;

    void main(void) {

        vec3 sunIntensity = vec3(0.9, 0.9, 0.9);
        vec3 sunPositions[3];
        sunPositions[0] = vec3(40.0, 0.0, -80.0);
        sunPositions[1] = vec3(-40.0, .0, -80.0);
        sunPositions[2] = vec3(0.0, -50.0, -80.0);

        vec3 eyeDirection = normalize(-fragPosition);

        float ka = 0.2;
        float kd = 0.6;
        float ks = 0.2;

        vec3 lightIntensity = ka * fragColor.xyz;
        vec3 sunDirection;

        for(int i = 0; i < 3; i++) {
            sunDirection = normalize(fragPosition - sunPositions[i]);
            lightIntensity += kd * fragColor.xyz * sunIntensity * max(dot(fragNormal, sunDirection), 0.0);
            vec3 reflectDirection = 2.0 * dot(sunDirection, fragNormal) * fragNormal - sunDirection;
            lightIntensity += ks * pow(max(dot(reflectDirection, eyeDirection), 0.0), 10.0) * sunIntensity;
        }

        gl_FragColor = vec4(lightIntensity, 1.0);

    }
</script>

<script id="PhongVertexShader" type="vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aFrontColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	varying vec4 fragColor;
    varying vec3 fragNormal;
    varying vec3 fragPosition;

    void main(void) {

        fragColor = vec4(aFrontColor.rgb, 1.0);
        fragNormal = normalize((uMVMatrix * vec4(aVertexNormal, 0.0)).xyz);
        fragPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;

        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script id="GouraudFragmentShader" type="fragment">
    precision mediump float;

    varying vec4 fragColor;

    void main(void) {

        gl_FragColor = fragColor;
    }
</script>

<script id="GouraudVertexShader" type="vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aFrontColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	varying vec4 fragColor;

    void main(void) {

        vec3 sunIntensity = vec3(0.9, 0.9, 0.9);
        vec3 sunPositions[3];
        sunPositions[0] = vec3(40.0, 0.0, -80.0);
        sunPositions[1] = vec3(-40.0, 0.0, -80.0);
        sunPositions[2] = vec3(0.0, -50.0, -80.0);

        vec3 MVPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
        vec3 MVNormal = normalize((uMVMatrix * vec4(aVertexNormal, 0.0)).xyz);

        vec3 eyeDirection = normalize(-MVPosition);

        float ka = 0.2;
        float kd = 0.6;
        float ks = 0.2;

        vec3 lightIntensity = ka * aFrontColor;
        vec3 sunDirection;

        for(int i = 0; i < 3; i++) {
            sunDirection = normalize(MVPosition - sunPositions[i]);
            lightIntensity += kd * aFrontColor * sunIntensity * max(dot(MVNormal, sunDirection), 0.0);
            vec3 reflectDirection = 2.0 * dot(sunDirection, MVNormal) * MVNormal - sunDirection;
            lightIntensity += ks * pow(max(dot(reflectDirection, eyeDirection), 0.0), 10.0) * sunIntensity;
        }
        fragColor = vec4(lightIntensity, 1.0);

        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script id="FlatFragmentShader" type="fragment">

    #extension GL_OES_standard_derivatives : enable

    precision mediump float;

    varying vec4 fragColor;
    varying vec3 fragNormal;
    varying vec3 fragPosition;

    void main(void) {

        vec3 sunIntensity = vec3(0.9, 0.9, 0.9);
        vec3 sunPositions[3];
        sunPositions[0] = vec3(40.0, 0.0, -80.0);
        sunPositions[1] = vec3(-40.0, .0, -80.0);
        sunPositions[2] = vec3(0.0, -50.0, -80.0);


        float ka = 0.2;
        float kd = 0.6;
        float ks = 0.2;

        vec3 U = dFdx(fragPosition);
        vec3 V = dFdy(fragPosition);
        vec3 N = normalize(cross(U, V));
        vec3 eyeDirection = normalize(-fragPosition);

        vec3 lightIntensity = ka * fragColor.xyz;
        vec3 sunDirection;

        for(int i = 0; i < 3; i++) {
            sunDirection = normalize(fragPosition - sunPositions[i]);
            lightIntensity += kd * fragColor.xyz * sunIntensity * max(dot(N, sunDirection), 0.0);
            vec3 reflectDirection = 2.0 * dot(sunDirection, N) * N - sunDirection;
            lightIntensity += ks * pow(max(dot(reflectDirection, eyeDirection), 0.0), 10.0) * sunIntensity;
        }

        gl_FragColor = vec4(lightIntensity, 1.0);

    }
</script>

<script id="FlatVertexShader" type="vertex">

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aFrontColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	varying vec4 fragColor;
    varying vec3 fragNormal;
    varying vec3 fragPosition;

    void main(void) {

        fragColor = vec4(aFrontColor.rgb, 1.0);
        fragNormal = (uMVMatrix * vec4(aVertexNormal, 0.0)).xyz;
        fragPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script type="text/javascript">
    // common variables
    var gl;
    var selectedShaderProgram;
    var FlatShaderProgram;
    var PhongShaderProgram;
    var GouraudShaderProgram;
    var ToonShaderProgram;

    var mvMatrices = new Array(3);
    for(var i = 0; i < 3; i++) {
        mvMatrices[i] = mat4.create();
    }
    var pMatrices  = new Array(3);
    for(var i = 0; i < 3; i++) {
        pMatrices[i] = mat4.create();
    }

    var objectVertexPositionBuffers = new Array(3);
    var objectVertexNormalBuffers = new Array(3);
    var objectVertexFrontColorBuffers = new Array(3);

    var objectAngles = [180, 180, 180];
    var lastTime    = 0;

    var defaultXoff = [-20, 0, 20];
    var defaultYoff = [2, 0, 0];
    var defaultXRotation = [-15, 0, -90];
    var defaultScaling = [2, 0.5, 5];
    var xoff = [0, 0, 0];
    var yoff = [0, 0, 0];
    var zoff = [0, 0, 0];
    var rotation = [0, 0, 0];
    var scaling = [1, 1, 1];
    var shearing = [90, 90, 90];

    function parseOBJ(text) {
      // because indices are base 1 let's just fill in the 0th data
      const objPositions = [[0, 0, 0]];
      const objTexcoords = [[0, 0]];
      const objNormals = [[0, 0, 0]];

      // same order as `f` indices
      const objVertexData = [
        objPositions,
        objTexcoords,
        objNormals,
      ];

      // same order as `f` indices
      let webglVertexData = [
        [],   // positions
        [],   // texcoords
        [],   // normals
      ];

      const materialLibs = [];
      const geometries = [];
      let geometry;
      let groups = ['default'];
      let material = 'default';
      let object = 'default';

      const noop = () => {};

      function newGeometry() {
        // If there is an existing geometry and it's
        // not empty then start a new one.
        if (geometry && geometry.data.position.length) {
          geometry = undefined;
        }
      }

      function setGeometry() {
        if (!geometry) {
          const position = [];
          const texcoord = [];
          const normal = [];
          webglVertexData = [
            position,
            texcoord,
            normal,
          ];
          geometry = {
            object,
            groups,
            material,
            data: {
              position,
              texcoord,
              normal,
            },
          };
          geometries.push(geometry);
        }
      }

      function addVertex(vert) {
        const ptn = vert.split('/');
        ptn.forEach((objIndexStr, i) => {
          if (!objIndexStr) {
            return;
          }
          const objIndex = parseInt(objIndexStr);
          const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
          webglVertexData[i].push(...objVertexData[i][index]);
        });
      }

      const keywords = {
        v(parts) {
          objPositions.push(parts.map(parseFloat));
        },
        vn(parts) {
          objNormals.push(parts.map(parseFloat));
        },
        vt(parts) {
          // should check for missing v and extra w?
          objTexcoords.push(parts.map(parseFloat));
        },
        f(parts) {
          setGeometry();
          const numTriangles = parts.length - 2;
          for (let tri = 0; tri < numTriangles; ++tri) {
            addVertex(parts[0]);
            addVertex(parts[tri + 1]);
            addVertex(parts[tri + 2]);
          }
        },
        s: noop,    // smoothing group
        mtllib(parts, unparsedArgs) {
          // the spec says there can be multiple filenames here
          // but many exist with spaces in a single filename
          materialLibs.push(unparsedArgs);
        },
        usemtl(parts, unparsedArgs) {
          material = unparsedArgs;
          newGeometry();
        },
        g(parts) {
          groups = parts;
          newGeometry();
        },
        o(parts, unparsedArgs) {
          object = unparsedArgs;
          newGeometry();
        },
      };

      const keywordRE = /(\w*)(?: )*(.*)/;
      const lines = text.split('\n');
      for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
        const line = lines[lineNo].trim();
        if (line === '' || line.startsWith('#')) {
          continue;
        }
        const m = keywordRE.exec(line);
        if (!m) {
          continue;
        }
        const [, keyword, unparsedArgs] = m;
        const parts = line.split(/\s+/).slice(1);
        const handler = keywords[keyword];
        if (!handler) {
          console.warn('unhandled keyword:', keyword);  // eslint-disable-line no-console
          continue;
        }
        handler(parts, unparsedArgs);
      }

      // remove any arrays that have no entries.
      for (const geometry of geometries) {
        geometry.data = Object.fromEntries(
            Object.entries(geometry.data).filter(([, array]) => array.length > 0));
      }

        console.log(geometries);
      return geometries;
    }

    function initSliders() {
        var name;
        var slider;
        for(var i = 0; i < 3; i++) {
            name = "xoff" + i.toString();
            slider = document.getElementById(name);
            slider.value = 50;
            slider.oninput = function() {
                var idx = Number(this.id.slice(-1));
                xoff[idx] = this.value / 5 - 10;
            }
            name = "yoff" + i.toString();
            slider = document.getElementById(name);
            slider.value = 50;
            slider.oninput = function() {
                var idx = Number(this.id.slice(-1));
                yoff[idx] = this.value / 5 - 10;
            }
            name = "zoff" + i.toString();
            slider = document.getElementById(name);
            slider.value = 50;
            slider.oninput = function() {
                var idx = Number(this.id.slice(-1));
                zoff[idx] = this.value / 5 - 10;
            }
            name = "shearing" + i.toString();
            slider = document.getElementById(name);
            slider.value = 50;
            slider.oninput = function() {
                var idx = Number(this.id.slice(-1));
                shearing[idx] = this.value / 100 * 90 + 45;
            }
            name = "scaling" + i.toString();
            slider = document.getElementById(name);
            slider.value = 50;
            slider.oninput = function() {
                var idx = Number(this.id.slice(-1));
                scaling[idx] = this.value / 50;
            }
            name = "rotation" + i.toString();
            slider = document.getElementById(name);
            slider.value = 50;
            slider.oninput = function() {
                var idx = Number(this.id.slice(-1));
                rotation[idx] = this.value / 100 * 360 - 180;
            }

        }
    }

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            gl.viewportWidth  = canvas.width;
            gl.viewportHeight = canvas.height;
        } 
        catch (e) {
        }

        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw 'extension not support';
        }
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var shaderSource = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                shaderSource += k.textContent;
            }

            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } 
        else if (shaderScript.type == "vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } 
        else {
            return null;
        }

        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function initShader(shaderName) {
        var fragmentShader = getShader(gl, shaderName + "FragmentShader");
        var vertexShader   = getShader(gl, shaderName + "VertexShader");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        return shaderProgram;
    }

    function selectShader(shaderProgram) {
        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
        shaderProgram.vertexFrontColorAttribute = gl.getAttribLocation(shaderProgram, "aFrontColor");
        gl.enableVertexAttribArray(shaderProgram.vertexFrontColorAttribute);

        shaderProgram.pMatrixUniform  = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        selectedShaderProgram = shaderProgram;
    }


    function setMatrixUniforms(idx) {
        gl.uniformMatrix4fv(selectedShaderProgram.pMatrixUniform, false, pMatrices[idx]);
        gl.uniformMatrix4fv(selectedShaderProgram.mvMatrixUniform, false, mvMatrices[idx]);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    function handleLoadedObject(objectData, idx) {
        objectVertexPositionBuffers[idx] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexPositionBuffers[idx]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(objectData.vertexPositions), gl.STATIC_DRAW);
        objectVertexPositionBuffers[idx].itemSize = 3;
        objectVertexPositionBuffers[idx].numItems = objectData.vertexPositions.length / 3;

        objectVertexNormalBuffers[idx] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexNormalBuffers[idx]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(objectData.vertexNormals), gl.STATIC_DRAW);
        objectVertexNormalBuffers[idx].itemSize = 3;
        objectVertexNormalBuffers[idx].numItems = objectData.vertexNormals.length / 3;

        objectVertexFrontColorBuffers[idx] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexFrontColorBuffers[idx]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(objectData.vertexFrontcolors), gl.STATIC_DRAW);
        objectVertexFrontColorBuffers[idx].itemSize = 3;
        objectVertexFrontColorBuffers[idx].numItems = objectData.vertexFrontcolors.length / 3;
    }

    function loadObject(name, idx) {
        var request = new XMLHttpRequest();
        request.responseType = "text";
        request.open("GET", "./model/" + name + ".json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedObject(JSON.parse(request.responseText), idx);
            }
        }
        request.send();
    }

    function drawScene() {

        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


        for(var i = 0; i < 3; i++) {

            if (objectVertexPositionBuffers[i]   == null || 
                objectVertexNormalBuffers[i]     == null || 
                objectVertexFrontColorBuffers[i] == null) {
                return;
            }
                
            // Setup Projection Matrix
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrices[i]);

            // Setup Model-View Matrix
            // rotate -> shear -> scale -> transalate
            mat4.identity(mvMatrices[i]);
            mat4.translate(mvMatrices[i], [0, 0, -40]);
            mat4.translate(mvMatrices[i], [defaultXoff[i], 0, 0]);
            mat4.translate(mvMatrices[i], [0, defaultYoff[i], 0]);
            mat4.translate(mvMatrices[i], [xoff[i], 0, 0]);
            mat4.translate(mvMatrices[i], [0, yoff[i], 0]);
            mat4.translate(mvMatrices[i], [0, 0, zoff[i]]);
            mat4.scale(mvMatrices[i], [defaultScaling[i], defaultScaling[i], defaultScaling[i]]);
            mat4.scale(mvMatrices[i], [scaling[i], scaling[i], scaling[i]]);
            var H = mat4.create();
            mat4.identity(H);
            if (shearing[i] != 0) {
                H[4] = 1 / Math.tan(degToRad(shearing[i]));
            }
            mat4.multiply(mvMatrices[i], H);
            mat4.rotate(mvMatrices[i], degToRad(objectAngles[i]), [0, 1, 0]);
            mat4.rotate(mvMatrices[i], degToRad(rotation[i]), [1, 0, 0]);
            mat4.rotate(mvMatrices[i], degToRad(defaultXRotation[i]), [1, 0, 0]);

            setMatrixUniforms(i);

            // Setup position data
            gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexPositionBuffers[i]);
            gl.vertexAttribPointer(selectedShaderProgram.vertexPositionAttribute, 
                                   objectVertexPositionBuffers[i].itemSize, 
                                   gl.FLOAT, 
                                   false, 
                                   0, 
                                   0);

            // Setup vertex norm data
            gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexNormalBuffers[i]);
            gl.vertexAttribPointer(selectedShaderProgram.vertexNormalAttribute, 
                                   objectVertexNormalBuffers[i].itemSize, 
                                   gl.FLOAT, 
                                   false, 
                                   0, 
                                   0);

            // Setup teapot front color data
            gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexFrontColorBuffers[i]);
            gl.vertexAttribPointer(selectedShaderProgram.vertexFrontColorAttribute, 
                                   objectVertexFrontColorBuffers[i].itemSize, 
                                   gl.FLOAT, 
                                   false, 
                                   0, 
                                   0);

            gl.drawArrays(gl.TRIANGLES, 0, objectVertexPositionBuffers[i].numItems);

        }
    }

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
            for(var i = 0; i < 3; i++) {
                objectAngles[i] += 0.03 * elapsed;
            }
        }
        
        lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
    }

    function webGLStart() {
        var canvas = document.getElementById("ICG-canvas");
        initGL(canvas);

        PhongShaderProgram = initShader("Phong");
        GouraudShaderProgram = initShader("Gouraud");
        FlatShaderProgram = initShader("Flat");
        ToonShaderProgram = initShader("Toon");

        changeShader(document.getElementById("shader"));
        initSliders();

        loadObject("Teapot", 1);
        loadObject("Car_road", 2)

        // load ICE CREAM here
        var request = new XMLHttpRequest();
        var obj;
        request.responseType = "text";
        request.open("GET", "./model/ice_cream.obj");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                obj = parseOBJ(request.responseText);

                var positions = Array(0);
                var normals = Array(0);
                for(var i = 0; i < 3; i++) {
                    positions = positions.concat(obj[i].data.position);
                    normals = normals.concat(obj[i].data.normal);
                }
                var colors = Array(normals.length);
                for(var i = 0; i < obj[0].data.position.length; i += 3) {
                    colors[i] = 255.0 / 255;
                    colors[i+1] = 250.0 / 255;
                    colors[i+2] = 240.0 / 255;
                }
                for(var i = 0; i < obj[1].data.position.length; i += 3) {
                    colors[obj[0].data.position.length + i] = 94.0 / 255 ;
                    colors[obj[0].data.position.length + i+1] = 38.0 / 255;
                    colors[obj[0].data.position.length + i+2] = 18.0 / 255;
                }
                for(var i = 0; i < obj[2].data.position.length; i += 3) {
                    colors[obj[0].data.position.length + obj[1].data.position.length + i] = 255.0 / 255;
                    colors[obj[0].data.position.length + obj[1].data.position.length + i+1] = 250.0 / 255;
                    colors[obj[0].data.position.length + obj[1].data.position.length + i+2] = 240.0 / 255;
                }

                objectVertexPositionBuffers[0] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexPositionBuffers[0]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                objectVertexPositionBuffers[0].itemSize = 3;
                objectVertexPositionBuffers[0].numItems = positions.length / 3;

                objectVertexNormalBuffers[0] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexNormalBuffers[0]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
                objectVertexNormalBuffers[0].itemSize = 3;
                objectVertexNormalBuffers[0].numItems = normals.length / 3;

                objectVertexFrontColorBuffers[0] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, objectVertexFrontColorBuffers[0]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                objectVertexFrontColorBuffers[0].itemSize = 3;
                objectVertexFrontColorBuffers[0].numItems = colors.length / 3;
            }
        }
        request.send();

        gl.clearColor(0.0, 0.2, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }

    function changeShader(selectObject) {
        switch(selectObject.value) {
            case "Flat": 
                selectShader(FlatShaderProgram);
                break;
            case "Gouraud": 
                selectShader(GouraudShaderProgram);
                break;
            case "Phong": 
                selectShader(PhongShaderProgram);
                break;
            case "Toon": 
                selectShader(ToonShaderProgram);
                break;
        }
    }
    
    function updateMVMatrix() {
    }
</script>
</head>

<body onload="webGLStart();">
    <canvas id="ICG-canvas" style="border: none;" width="1280" height="720"></canvas>
    <br/>
    <label for="shader">Shading Method:</label>
    <select name="shader" id="shader" onchange="changeShader(this)">
        <option value="Flat">Flat Shading</option>
        <option value="Gouraud">Gouraud Shading</option>
        <option value="Phong">Phong Shading</option>
        <option value="Toon">Toon Shading</option>
    </select>
    </br>
    <table>
        <tr>
            <th></th>
            <th>Ice_cream</th>
            <th>Teapot</th>
            <th>Car_road</th>
        </tr>
        <tr>
            <th>X offset</th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="xoff0">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="xoff1">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="xoff2">
            </th>
        </tr>
        <tr>
            <th>Y offset</th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="yoff0">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="yoff1">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="yoff2">
            </th>
        </tr>
        <tr>
            <th>Z offset</th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="zoff0">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="zoff1">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="zoff2">
            </th>
        </tr>
        <tr>
            <th>Rotaion</th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="rotation0">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="rotation1">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="rotation2">
            </th>
        </tr>
        <tr>
            <th>Scaling</th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="scaling0">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="scaling1">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="scaling2">
            </th>
        </tr>
        <tr>
            <th>Shearing</th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="shearing0">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="shearing1">
            </th>
            <th>
            <input type="range" min="0" max="100" value="50" class="slider" id="shearing2">
            </th>
        </tr>
    </table>
</body>

</html>
